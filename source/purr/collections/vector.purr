language purr.core

module purr.collections.vector
  provides { Vector, _ === _, _ =/= _, _ at: _ }
  uses purr.intrinsics.types { Vector }
  uses purr.intrinsics.primitives { vec_eq, vec_neq, vec_at, vec_size, vec_concat, vec_map, vec_flatmap, vec_filter, vec_zip, vec_zipwith, vec_sort }
  uses purr.base.optional { Optional }
  uses purr.base.ordering { Ordering }
  uses purr.numeric.integer { Integer, _ >= _, _ <= _ }
  uses purr.base.boolean { _ and _ }
  uses purr.numeric.integer { _ > _, _ < _ } for testing
  uses purr.testing { _ ==> _ } for testing


  define (a is Vector) === (b is Vector) =
    vec_eq(a, b)
  where
    assert [] === [];
    assert [1, 2] === [1, 2];
    assert [[1], [2]] === [[1], [2]]


  define (a is Vector) =/= (b is Vector) =
    vec_neq(a, b)
  where
    assert [1, 2, 3] =/= [1, 2];
    assert [1, [2]] =/= [1, 2];
    assert [1, 2] =/= [2, 1]


  define (a is Vector) count =
    vec_size(a)
  where
    assert [] count ==> 0;
    assert [1] count ==> 1;
    assert [1, 2] count ==> 2;
    assert [1, [2]] count ==> 2
  

  define (a is Vector) at: (index is Integer) =
    if index >= 1 and index <= a count then
      Optional.some: vec_at(a, index)
    else
      Optional.nothing
  where
    assert [1, 2] at: 1 ==> Optional.some: 1;
    assert [1, 2] at: 2 ==> Optional.some: 2;
    assert [] at: 1     ==> Optional.nothing;
    assert [1] at: 0    ==> Optional.nothing


  define (a is Vector) first = a at: 1
  where
    assert [] first     ==> Optional.nothing;
    assert [1, 2] first ==> Optional.some: 1

  define (a is Vector) last = a at: a count
  where
    assert [] last      ==> Optional.nothing;
    assert [1, 2] last  ==> Optional.some: 2

  
  define (a is Vector) + (b is Vector) =
    vec_concat(a, b)
  where
    assert [] + [1]  ==> [1];
    assert [1] + []  ==> [1];
    assert [1] + [2] ==> [1, 2]

  
  define (a is Vector) map: transformation =
    vec_map(a, transformation)
  where
    assert [1, 2] map: { x in [x] } ==> [[1], [2]];
    assert [] map: { x in [x] } ==> []

  
  define (a is Vector) flatmap: transformation =
    vec_flatmap(a, transformation)
  where
    assert [1, 2] flatmap: { x in [x, x] } ==> [1, 1, 2, 2];
    assert [] flatmap: { x in [x, x] } ==> []


  define (a is Vector) filter: predicate =
    vec_filter(a, predicate)
  where
    assert [1, 2, 3] filter: { x in x >= 2 } ==> [2, 3]
  

  define (a is Vector) zip: (b is Vector) =
    assert a count === b count;
    vec_zip(a, b)
  where
    assert [1, 2] zip: ["a", "b"]  ==> [[1, "a"], [2, "b"]]

  define (a is Vector) zip: (b is Vector) with: zipper =
    assert a count === b count;
    vec_zipwith(a, b, zipper)
  where
    assert [1, 2] zip: [1, 3] with: { x, y in x >= y }  ==> [true, false]


  define (a is Vector) sort: comparator =
    vec_sort(a, { x, y in match comparator(x, y)
                            case Ordering.less_than    do -1
                            case Ordering.equal        do  0
                            case Ordering.greater_than do  1
                })
  where
    assert [3, 1, 2] sort: { x, y in
      if      x > y then Ordering.greater_than
      else if x < y then Ordering.less_than
      else               Ordering.equal
    } ==> [1, 2, 3]
  

