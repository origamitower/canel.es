language purr.core.kernel

module purr.core.parser where
  public (parse)
  foreign "../../ohm.js" as ohm
  from purr.prelude use (
    _ resource:, 
    parse_integer:, 
    parse_decimal:, 
    _ map:, 
    +, 
    _ join:,
    read_file,
    trace
  )
  from purr.core.ast use (
    Name, Selector, Module, Declaration, Binding, Variant, Field, Signature, Argument, Keyword,
    Boolean, Value, Expression, Let_Binding, Case, Pattern, Vector_Pattern, Qualified_Id,
    Dispatch_Keyword, Field_Map, Method_Keyword, Field_Pattern
  )

  define grammar = self resource: "grammar.ohm"  

  define name: x = Name{ value = x }

  define source parse =
    let ast = ohm.parse(ohm.grammar(grammar read_file), source)
    in ast reified


  # currently very error prone
  define node reified =
    match node
      case ["Module", _, id, _, declarations] do
        Module{ 
          interface = id reified, 
          declarations = declarations map: { x in x reified }
        }

      case ["Interface_Name", ids] do
        Qualified_Id{ value = ids map: { x in x reified }}

      case ["Name", id] do
        Name{ value = id }

      # Record
      case ["Record", _, name, fields] do
        Declaration.Record{ 
          name = name reified, 
          fields = fields reified
        }

      case ["Record_Mapping", _, fields, _] do fields map: { x in x reified }
      case ["Record_Field", name]           do Field{ name = name }

      # Union
      case ["Union", _, name, variants] do
        Declaration.Union{ 
          name = name reified, 
          variants = variants map: { x in x reified }
        }

      case ["Union_Case_nary", _, name, fields] do
        Variant{ 
          tag = name reified, 
          fields = fields reified
        }

      case ["Union_Case_nullary", _, name] do
        Variant{ 
          tag = name reified, 
          fields = []
        }

      # Import
      case ["Import", _, interface, _, _, bindings, _] do
        Declaration.Use { 
          interface = interface reified, 
          bindings = bindings map: { x in x reified }
        }

      case ["Binding_alias", selector, _, alias] do
        Binding{ 
          selector = selector reified, 
          alias = alias reified
        }

      case ["Binding_name", selector] do
        Binding{ 
          selector = selector reified, 
          alias = selector reified
        }

      case ["Selector", name] do
        Selector{ value = name }

      # Export
      case ["Export", _, _, bindings, _] do
        Declaration.Public{ 
          bindings = bindings map: { x in x reified }
        }

      # Method
      case ["Method_not", _, _, param, _, body] do
        Declaration.Method{
          signature = Signature.Unary{ name = name: "not", argument = param reified },
          body = body reified
        }

      case ["Method_binary", _, arg1, op, arg2, _, body] do
        Declaration.Method{
          signature = Signature.Binary{ operator = name: op reified, left = arg1 reified, right = arg2 reified },
          body = body reified
        }

      case ["Method_keywords_plus_param", _, arg, kws, _, body] do
        Declaration.Method{
          signature = Signature.Keyword_With_Leading_Argument{ 
                        argument = arg reified, 
                        keywords = kws map: { x in x reified }
                      },
          body = body reified
        }

      case ["Method_keywords", _, kws, _, body] do
        Declaration.Method{
          signature = Signature.Keyword{ 
                        keywords = kws map: { x in x reified } 
                      },
          body = body reified
        }

      case ["Method_unary", _, arg, name, _, body] do
        Declaration.Method{
          signature = Signature.Unary{ name = name reified, argument = arg reified },
          body = body reified
        }

      case ["Method_thunk", _, name, _, body] do
        Declaration.Method{
          signature = Signature.Nullary{ name = name reified },
          body = body reified
        }

      case ["Method_Param_just_name", id] do
        Argument.Untyped{ name = id }

      case ["Method_Param_name_and_contract", _, name, _, expr, _] do
        Argument.Typed{ 
          name = name reified,
          type = expr reified
        }

      case ["Keyword", x] do
        Keyword{
          value = x
        }
        

      case ["Method_Keyword", kw, arg] do
        Method_Keyword{ 
          name = kw reified, 
          argument = arg reified
        }

      # FFI
      case ["FFI", _, path, _, name] do
        Declaration.Foreign{
          path = path reified,
          name = name reified
        }


      # Expressions
      case ["If", _, cond, _, consequent, _, alternate] do
        Expression.If{
          condition = cond reified,
          consequent = consequent reified,
          alternate = alternate reified
        }

      # Let
      case ["Let", bindings, _, expr] do
        Expression.Let{
          bindings = bindings map: { x in x reified },
          expression = expr reified
        }

      case ["Let_Binding", _, name, _, value] do
        Let_Binding{ 
          name = name reified,
          value = value reified
        }

      # Function calls
      case ["Keyword_Call_param_first", arg1, kws] do 
        Expression.Dispatch_Keyword_With_Argument{
          argument = arg1 reified,
          keywords = kws map: { x in x reified }
        }

      case ["Keyword_Call_keyword_first", kws] do
        Expression.Dispatch_Keyword{ 
          keywords = kws map: { x in x reified }
        }

      case ["Keyword_Apply", kw, arg] do
        Dispatch_Keyword{ 
          keyword = kw reified, 
          argument = arg reified
        }

      case ["Logical_and", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "and",
          left = left reified,
          right = right reified
        }

      case ["Logical_or", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "or",
          left = left reified,
          right = right reified
        }

      case ["Negate_not", _, arg] do
        Expression.Dispatch_Unary{
          name = name: "not",
          argument = arg reified
        }

      case ["Relational_eq", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "===",
          left = left reified,
          right = right reified
        }

      case ["Relational_not_eq", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "=/=",
          left = left reified,
          right = right reified
        }

      case ["Relational_gte", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: ">=",
          left = left reified,
          right = right reified
        }

      case ["Relational_lte", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "<=",
          left = left reified,
          right = right reified
        }

      case ["Relational_gt", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: ">",
          left = left reified,
          right = right reified
        }

      case ["Relational_lt", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "<",
          left = left reified,
          right = right reified
        }

      case ["Add_add", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "+",
          left = left reified,
          right = right reified
        }

      case ["Add_sub", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "-",
          left = left reified,
          right = right reified
        }

      case ["Multiply_mul", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "*",
          left = left reified,
          right = right reified
        }

      case ["Multiply_div", left, _, right] do
        Expression.Dispatch_Binary{
          operator = name: "/",
          left = left reified,
          right = right reified
        }

      case ["Unary_unary_app", arg, name] do
        Expression.Dispatch_Unary{
          name = name reified,
          argument = arg reified
        }
      
      case ["Unary_call", callee, _, args, _] do
        Expression.Call{
          callee = callee reified,
          arguments = args map: { x in x reified }
        }

      case ["Unary_new", struct, _, fields, _] do
        Expression.New{
          structure = struct reified,
          fields = fields map: { x in x reified }
        }

      case ["Field_Map", name, _, expr] do
        Field_Map{
          name = name reified,
          expression = expr reified
        }

      case ["Postfix_project", expr, _, field] do
        Expression.Project{
          structure = expr reified,
          field = field reified
        }

      case ["Primary_variable", name] do
        Expression.Variable{
          name = name reified
        }

      case ["Primary_group", _, expr, _] do
        expr reified

      # Pattern matching
      case ["Match", _, expr, cases] do
        Expression.Match{
          value = expr reified,
          cases = cases map: { x in x reified }
        }

      case ["Match_Case", _, pattern, _, expr] do
        Case{
          pattern = pattern reified,
          expression = expr reified
        }

      case ["Pattern", x] do x reified

      case ["Pattern_any", _] do
        Pattern.Any

      case ["Pattern_boolean", x] do
        Pattern.Equals{ expression = x reified }
      
      case ["Pattern_integer", x] do
        Pattern.Equals{ expression = x reified }

      case ["Pattern_decimal", x] do
        Pattern.Equals{ expression = x reified }

      case ["Pattern_text", x] do
        Pattern.Equals{ expression = x reified }

      case ["Pattern_unapply", extractor, _, fields, _] do
        Pattern.Unapply{
          extractor = extractor reified,
          fields = fields map: { x in x reified }
        }

      case ["Pattern_vector_wrapper", x] do x reified

      case ["Pattern_bind", x] do
        Pattern.Bind{ name = x reified }

      case ["Pattern_group", x] do x reified

      case ["Pattern_Vector", x] do x reified

      case ["Pattern_Vector_empty", _, _] do
        Pattern.Vector{ items = [] }

      case ["Pattern_Vector_items", _, xs, _] do
        Pattern.Vector{
          items = xs map: { x in x reified }
        }

      case ["Pattern_Vector_items_rest", _, items, _, spread, _] do
        Pattern.Vector_Spread{
          items = items map: { x in x reified },
          spread = spread reified
        }

      case ["Pattern_Vector_rest", _, spread, _] do
        Pattern.Vector_Spread{
          items = [],
          spread = spread reified
        }

      case ["Pattern_Vector_Rest_bind", _, name] do
        Pattern.Bind{ name = name reified }

      case ["Pattern_Vector_Rest_any", _, _] do
        Pattern.Any

      case ["Field_Pattern_equal", name, _, expression] do
        Field_Pattern{
          field = name reified,
          pattern = Pattern.Equals{ expression = expression reified }
        }

      case ["Field_Pattern_bind", name, _, alias] do
        Field_Pattern{
          field = name reified,
          pattern = Pattern.Bind{ name = alias reified }
        }
      
      case ["Field_Pattern_define", name] do
        let x = name reified in 
        Field_Pattern{
          field = x,
          pattern = Pattern.Bind{ name = x }
        }
      

      # values
      case ["Boolean", "true"] do 
        Value.Boolean{ value = Boolean.True }

      case ["Boolean", "false"] do
        Value.Boolean{ value = Boolean.False }

      case ["Text", x] do 
        Value.Text{ characters = x }

      case ["Integer", x] do 
        Value.Integer{ value = parse_integer: x }

      case ["Decimal", x] do 
        Value.Decimal{ value = parse_decimal: x }

      case ["Vector", _, xs, _] do
        Value.Vector{ items = xs map: { x in x reified } }

      case ["Closure_with_parameters", _, params, _, expr, _] do
        Value.Closure{
          parameters = params reified,
          body = expr reified
        }
      
      case ["Closure_nullary", _, expr, _] do
        Value.Closure{
          parameters = [],
          body = expr reified
        }

      case ["Closure_Parameters", xs] do xs map: { x in x reified }

      # Things that are incidentally wrapped
      case ["Declaration", x]     do x reified
      case ["Method_Body", x]     do x reified
      case ["Expression", x]      do x reified
      case ["Value", x]           do x reified
      case ["Program", x]         do x reified
      case ["Closure", x]         do x reified
      case ["Union_Case", x]      do x reified
      case ["Method", x]          do x reified
      case ["Method_Param", x]    do x reified
      case ["Keyword_Call", x]    do x reified
      case ["Logical", x]         do x reified
      case ["Negate", x]          do x reified
      case ["Relational", x]      do x reified
      case ["Add", x]             do x reified
      case ["Multiply", x]        do x reified
      case ["Unary", x]           do x reified
      case ["Postfix", x]         do x reified
      case ["Primary", x]         do x reified
      case ["Binding", x]         do x reified
