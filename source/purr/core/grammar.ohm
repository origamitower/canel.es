// The grammar for Core 0.1 is defined in this file.
// Note that we skip the language heading, as that's parsed
// by the compiler in order to decide which grammar/compiler
// to use for the rest of the file.

Purr_Core {
  Program = Module // entry point

  // -- HIGHER-ORDER RULES --------------------------------------------
  lexeme<x> = x ~(":" | "." | id_rest)

  // -- LEXICAL RULES -------------------------------------------------
  newline = "\n\r"      // old OS/X convention
          | "\r\n"      // Windows convention
          | "\n"        // Linux convention
          | "\r"        // OS/X convention
  
  comment = "#" (~newline any)* newline

  space += comment

  // --- Booleans
  boolean_literal = lexeme<"true">      -- true
                  | lexeme<"false">     -- false

  // --- Numbers
  integer_literal =     digits         -- unsigned
                  | "+" digits         -- positive
                  | "-" digits         -- negative

  decimal_literal =     digits "." digits     -- unsigned
                  | "+" digits "." digits     -- positive
                  | "-" digits "." digits     -- negative

  digits = digit+

  // --- Names
  reserved = and        
           | as            
           | case          
           | define     
           | do            
           | else          
           | foreign    
           | from          
           | if            
           | in         
           | is            
           | let
           | match         
           | module     
           | not           
           | or            
           | public     
           | record        
           | then          
           | union      
           | use           
           | where

  and     = lexeme<"and">
  as      = lexeme<"as">
  case    = lexeme<"case">
  define  = lexeme<"define">
  do      = lexeme<"do">
  else    = lexeme<"else">
  foreign = lexeme<"foreign">
  from    = lexeme<"from">
  if      = lexeme<"if">
  in      = lexeme<"in">
  is      = lexeme<"is">
  let     = lexeme<"let">
  match   = lexeme<"match">
  module  = lexeme<"module">
  not     = lexeme<"not">
  or      = lexeme<"or">
  public  = lexeme<"public">
  record  = lexeme<"record">
  then    = lexeme<"then">
  union   = lexeme<"union">
  use     = lexeme<"use">
  where   = lexeme<"where">

  id_start   = letter
  id_rest    = letter | digit | "_"
  identifier = ~reserved id_start id_rest*
  keyword    = id_start id_rest* ":"

  binary = and                  | or            | not
         | lexeme<">=">         | lexeme<">">
         | lexeme<"<=">         | lexeme<"<">
         | lexeme<"===">        | lexeme<"=/=">
         | lexeme<"/">          | lexeme<"*">
         | lexeme<"+">          | lexeme<"-">

  selector = binary
           | signature
           | identifier

  signature = "_" space+ keyword      -- object_first
            | keyword                 -- keyword_first


  // ---- Text
  text_character = text_escape_sequence     -- with_escapes
                 | ~"\"" any                -- regular

  raw_text_character = ~"\"\"\"" any

  text_escape_sequence = "\\" text_character_escaped
  text_character_escaped = "\\"         -- slash 
                         | "b"          -- backspace
                         | "f"          -- form_feed
                         | "n"          -- newline
                         | "r"          -- return
                         | "t"          -- tab
                         | "v"          -- vertical_space
                         | "\""         -- quote

  text_literal = "\"\"\"" raw_text_character* "\"\"\""    -- raw
               | "\"" text_character* "\""                -- escaped

  
  // -- VALUES --------------------------------------------------------
  Value = Boolean | Text | Integer | Decimal | Vector | Closure

  Boolean = boolean_literal
  Text    = text_literal
  Integer = integer_literal
  Decimal = decimal_literal

  Vector = "[" ListOf<Expression, ","> "]"

  Closure = "{" Closure_Parameters in Expression "}"    -- with_parameters
          | "{" Expression "}"                          -- nullary
  Closure_Parameters = ListOf<Name, ",">


  // -- DECLARATIONS --------------------------------------------------
  Module = module Interface_Name where Declaration*
  Interface_Name = NonemptyListOf<Name, ".">
  Name = identifier

  Declaration = Record | Union | Import | Export | Method | FFI

  Record = record Name Record_Mapping
  Record_Mapping = "{" ListOf<Record_Field, ","> "}"
  Record_Field = identifier

  Union = union Name Union_Case+
  Union_Case = case Name Record_Mapping   -- nary
             | case Name                  -- nullary

  Import = from Interface_Name use "(" NonemptyListOf<Binding, ","> ")"
  Binding = Selector as Selector  -- alias
          | Selector              -- name
  Selector = selector

  Export = public "(" NonemptyListOf<Binding, ","> ")"

  Method = define not Method_Param                  "=" Method_Body     -- not
         | define Method_Param binary Method_Param  "=" Method_Body     -- binary
         | define Method_Param Method_Keyword+      "=" Method_Body     -- keywords_plus_param
         | define Method_Keyword+                   "=" Method_Body     -- keywords
         | define Method_Param Name                 "=" Method_Body     -- unary
         | define Name                              "=" Method_Body     -- thunk

  Method_Param = Name                         -- just_name
               | "(" Name is Expression ")"   -- name_and_contract

  Keyword = keyword
  Method_Keyword = Keyword Method_Param

  Method_Body = Expression

  FFI = foreign Text as Name


  // -- EXPRESSIONS ---------------------------------------------------
  Expression = If
             | Let
             | Match
             | Keyword_Call

  If = if Expression then Expression else Expression

  Let = Let_Binding+ in Expression
  Let_Binding = let Name "=" Expression

  Match = match Expression Match_Case+
  Match_Case = case Pattern do Expression
  Pattern = "_"                                         -- any
          | Boolean                                     -- boolean
          | Integer                                     -- integer
          | Decimal                                     -- decimal
          | Text                                        -- text
          | Postfix "{" ListOf<Field_Pattern, ","> "}"  -- unapply
          | Pattern_Vector                              -- vector_wrapper
          | Name                                        -- bind
          | "(" Pattern ")"                             -- group

  Pattern_Vector = "[" "]"                                                              -- empty
                 | "[" NonemptyListOf<Pattern, ","> "]"                                 -- items
                 | "[" NonemptyListOf<Pattern, ","> "," Pattern_Vector_Rest "]"         -- items_rest
                 | "[" Pattern_Vector_Rest "]"                                          -- rest

  Pattern_Vector_Rest = "..." Name      -- bind
                      | "..." "_"       -- any

  Field_Pattern = Name "=" Expression                -- equal
                | Name as Name                       -- bind
                | Name                               -- define


  Keyword_Call = Logical Keyword_Apply+         -- param_first
               | Keyword_Apply+                 -- keyword_first
               | Logical

  Keyword_Apply = Keyword Logical

  Logical = Logical and Negate          -- and
          | Logical or Negate           -- or
          | Negate

  Negate = not Relational     -- not
         | Relational

  Relational = Relational lexeme<"==="> Add       -- eq
             | Relational lexeme<"=/="> Add       -- not_eq
             | Relational lexeme<">=">  Add       -- gte
             | Relational lexeme<"<=">  Add       -- lte
             | Relational lexeme<">">   Add       -- gt
             | Relational lexeme<"<">   Add       -- lt
             | Add

  Add = Add "+" Multiply        -- add
      | Add "-" Multiply        -- sub
      | Multiply

  Multiply = Multiply "*" Unary   -- mul
           | Multiply "/" Unary   -- div
           | Unary

  Unary = Unary Name ~":"                                 -- unary_app
        | Unary "(" ListOf<Expression, ","> ")"           -- call
        | Unary "{" NonemptyListOf<Field_Map, ","> "}"    -- new
        | Postfix

  Field_Map = Name "=" Expression

  Postfix = Postfix "." Name        -- project
          | Primary

  Primary = Value
          | Name ~":"     -- variable
          | "(" Expression ")"  -- group
}