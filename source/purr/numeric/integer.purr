language purr.core.kernel

module purr.numeric.integer
  provides { 
    Integer,
    _ === _, _ =/= _,
    _ + _, _ - _, _ * _, _ / _,
    negate
  }
  uses purr.intrinsics.types { Integer }
  uses purr.intrinsics.primitives { int_eq, int_neq, int_add, int_div, int_mul, int_not, int_sub, int_not }
  uses purr.base.optional { Optional, _ nothing, _ some: _ }
  uses purr.testing { _ ==> _ } for testing


  #: True if both integers are equal
  define (a is Integer) === (b is Integer) =
    int_eq(a, b)
  where
    assert 0 === 0;
    assert 1 === 1;
    assert 1000 === 1000

  #: True if both integers are different
  define (a is Integer) =/= (b is Integer) =
    int_neq(a, b)
  where
    assert 1 =/= 0;
    assert 1000 =/= 1;
    assert 2 =/= 20

  #: Arithmetic addition
  define (a is Integer) + (b is Integer) =
    int_add(a, b)
  where
    assert 1 + 0  ==> 1;
    assert 2 + 2  ==> 4;
    assert 2 + -1 ==> 1

  #: Arithmetic subtraction
  define (a is Integer) - (b is Integer) =
    int_sub(a, b)
  where
    assert 1 - 0 ==>  1;
    assert 1 - 1 ==>  0;
    assert 1 - 2 ==> -1

  #: Arithmetic multiplication
  define (a is Integer) * (b is Integer) =
    int_mul(a, b)
  where
    assert 2 * 0 ==> 0;
    assert 2 * 1 ==> 2;
    assert 2 * 2 ==> 4

  #FIXME: this should return an arbitrary-precision rational
  #: Arithmetic division
  define (a is Integer) / (b is Integer) =
    if b === 0 then
      Optional.nothing
    else
      Optional.some: int_div(a, b)
  where
    assert 2 / 0 ==> Optional.nothing;
    assert 0 / 2 ==> Optional.some: 0;
    assert 4 / 2 ==> Optional.some: 2;
    assert 4 / 3 ==> Optional.some: 1


  define (a is Integer) negate =
    int_not(a)
  where
    assert 1 negate  ==> -1;
    assert -1 negate ==>  1;
    assert 0 negate  ==>  0
