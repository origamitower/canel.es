language purr.core

module benchmark.factorial
  provides { factorial }
  uses purr.numeric.integer { Integer, _ - _, _ + _, _ * _, _ === _ }
  uses purr.numeric.decimal { Decimal, _ - _, _ + _, _ * _, _ === _ }
  uses purr.testing.benchmark { _ time: _ repeat: _, _ suite: _ } for benchmarking
  uses purr.intrinsics.primitives { ffi_require, ffi_project }

  define n factorial =
    match n
      case 0 do 1
      case 1 do 1
      case _ do (n - 1) factorial * n
  where
    assert 5 factorial === 120

  define n factorial_float =
    match n
      case 0.0 do 1.0
      case 1.0 do 1.0
      case _ do (n - 1.0) factorial_float * n
  where
    assert 5.0 factorial_float === 120.0

  % benchmark
  define factorial_int = {
    let js = ffi_require(self, "./baseline/factorial.js")
    let fac_int = ffi_project(js, "fac_int")
    in
    "factorial" suite: [
      "integer"        time: { 30 factorial } repeat: 100,
      "baseline int"   time: { fac_int(30) } repeat: 100
    ]
  }

  % benchmark
  define factorial_float = {
    let js = ffi_require(self, "./baseline/factorial.js")
    let fac_float = ffi_project(js, "fac_float")
    in
    "factorial" suite: [
      "float"          time: { 30.0 factorial_float } repeat: 100,
      "baseline float" time: { fac_float(30.0) } repeat: 100
    ]
  }
