#+TYP_TODO: Info Open | Done

* Info Layers

A layer is a minimal compiler from language A to Core. The compiler is
given the Core AST object so it can construct proper Core AST nodes, and
the source code of its language to compile, and must return a Core AST.

#+BEGIN_SRC mli
type Layer : (CanelesCoreAST) => (String) => CanelesCoreAST
#+END_SRC

This Core AST is then fed to the backend compiler pipeline that will
translate it into some executable form.

Layers make writing new domain specific languages trivial, and allows
these DSLs to leverage existing tooling, libraries, and runtime.

This last part is particularly important for teaching (see next section).


* Info Canelés as a Teaching Tool

Sure. So, I think teaching programming would benefit from an approach similar to
what's described in CTM
(https://mitpress.mit.edu/books/concepts-techniques-and-models-computer-programming),
where you introduce concepts gradually, using a language that has been designed
specifically for that concept.

This avoids the problems with choosing a single language for teaching
everything: "we're going to see how concurrency works, oh but JavaScript only
has CPS-based concurrency so we can't talk about threads or parallelism" or
"we're going to see how asynchronous concurrency works, but that's a pain in
Java because the language has poor support to continuations." or "we're going to
talk about types, but JavaScript is untyped." or "we'd like to talk about
structural typing, but Java only includes nominal typing."

But then using different languages also has its own problems as well: semantics,
tooling, packages, etc. are all different, so to teach a simple concept in a
better-suited language you need to get your students to learn all of this new
stuff which they shouldn't ​*need*​ to.

Racket's ecosystem is very close to this ideal, I suppose: you define which
language you're using, and that language module provides all features for this
new language, but you'll still use the same tooling you're used to. Which is
great. But I think Racket not having a web-based implementation of something
like DrRacket, and having most languages using uncommon syntax like
S-expressions increases the barrier-to-entry significantly.

So, Canelés mainly tries to address this point: "how do we teach people all of
these different forms of programming, and how do we do it gradually, without
compromising too much by not being able to pick too many languages, and not
being able to teach particular concepts because the language we've chosen
doesn't work for that?".


As a way to implement that, I'm thinking in writing a web-based IDE for Canelés,
that's like DrRacket, and allows people to easily use all of these different
programming languages right from their web browser, and inspect programs in the
same way they're used to.

This allows teaching concepts gradually, and having students focus on those
concepts, by providing smaller and more focused teaching languages. One should
also be able to let the teaching language provide new features to the IDE,
though I have no idea of how to work with that yet. But at the very least, all
languages should share some common set of IDE features, so people can work with
them to understand their program, and understand why their program doesn't
work/how to fix it.


* Open Multiple runtimes

If we're having multiple languages, then each language must define its own
runtime. But how do we manage all of these different runtimes when building?

Currently every module is parameterised on a root runtime. The root runtime
provides a =selectRuntime(languageIdentifier)= method, that's called to
choose the runtime for that module, and it's up to the root runtime to
figure out how to translate these language identifiers to actual runtime
services.

Things that still need figuring out:

- How do we make sure that runtimes can't conflict?
- Should we have the language describe which runtime it's using? Do we support this in Core?


