function ToNumber(sign, integral, decimal) {
  sign    = sign || '+';
  decimal = decimal || '0';

  return Number(sign + integral + '.' + decimal) ;
}

ometa Core {
  kw :xs  = seq(xs) ~(letter | digit | '-' | ':'),
  comment = ';' (~eol anything)*,
  eol     = '\r' | '\n',
  space   = ' ' | '\t',
  ws      = comment | space | eol,
  _       = ws*,
  eof     = ~char,

  sign   = '-' | '+',
  digit  = /\d/,
  digits = <digit+>,
  number = sign?:s digits:a ('.' digits)?:b -> [#num, ToNumber(s, a, b)],

  stringEscape = '\\' '"',
  stringChar   = stringEscape
               | ~'"' anything,
  string       = '"' <stringChar*>:cs '"' -> [#str, cs],

  boolean = kw('true') -> [#bool, true]
          | kw('false') -> [#bool, false],

  nameSymbols = '!' | '@' | '%' | '*' | '-' | '_' | '+' | '=' | '~' | '^' | '<' | '>' | '|' | '?' | '/',
  letter      = /[a-zA-Z]/,
  nameStart   = nameSymbols | letter,
  nameRest    = nameSymbols | letter | digit,
  name        = <nameStart nameRest*>:cs -> [#id, cs],
  qualified   = name:n ('.' name)*:ns -> [#qualid, [n].concat(ns)],

  declaration =
    '(' _ kw('union') _ name:n (_ variant)+:vs _ ')' -> [#union, n, vs]
  | '(' _ kw('record') _ name:n (_ name)+:ns _ ')' -> [#record, n, ns]
  | '(' _ kw('define') _ name:n _ args:a _ expr:e _ ')' -> [#define, n, a, e],

  variant = '(' _ name:n (_ name)*:ns _ ')' -> [n, ns],

  args = '(' _ ')' -> []
       | '(' _ name:n (_ name)*:ns _ ')' -> [n].concat(ns),

  expr = 
    '(' _ kw('if') _ expr:a _ expr:b _ expr:c _ ')' -> [#if, a, b, c]
  | '(' _ kw('let') _ name:n _ expr:v _ expr:e _ ')' -> [#let, n, v, e]
  | '(' _ kw('invoke') _ name:n (_ expr)*:es _ ')' -> [#invoke, n, es]
  | '(' _ kw('apply') _ expr:e (_ expr)*:es _ ')' -> [#apply, e, es]
  | '(' _ kw('lambda') _ args:a _ expr:e _ ')' -> [#lambda, a, e]
  | '(' _ kw('tuple') (_ expr):es _ ')' -> [#tuple, es]
  | '(' _ kw('make-record') _ name:n (_ pair)+:ps _ ')' -> [#mkrecord, n, ps]
  | '(' _ kw('make-variant') _ name:n _ name:v (_ expr)*:es _ ')' -> [#mkvariant, n, v, es]
  | '(' _ kw('project') _ expr:e _ name:n _ ')' -> [#project, e, n]
  | '(' _ kw('match') _ expr:e (_ matchCase)+:cs _ ')' -> [#match, e, cs]
  | string | boolean | number,

  pair = name:n _ expr:e -> [n, e],

  matchCase = '(' _ pattern:p _ '(' (_ name)*:ns _ ')' _ expr:e _ ')' -> [p, ns, e],

  pattern =
    '(' _ kw('any') _ ')' -> [#any]
  | '(' _ kw('equal') _ expr:e _ ')' -> [#equal, e]
  | '(' _ kw('tuple') _ number:n _ ')' -> [#tuple, n]
  | '(' _ kw('record') _ name:n _ '(' (_ name)*:ns _ ')' _ ')' -> [#record, n, ns]
  | '(' _ kw('variant') _ name:n _ name:v _ ')' -> [#variant, n, v],

  program = '(' _ kw('module') _ qualified:id (ws+ declaration)*:ds _ ')' _ eof -> [id, ds]
}