language purr.core 0.1

module purr.core.parser where
  from purr.prelude use (map:)
  from purr.core.ast use (Module, Interface_Specifier, Name, Qualified_Name, Declaration, Field, Variant, Binding_Specifier, Method_Parameter, Method_Dispatch, Expression, Case, Pattern, Version)
  from pure.core.parser_js use (parse_raw)
  public (parse)


  define text parse = text parse_raw reify

  define ast reified = match ast
    # -- LEXICAL --
    case ["id", x]          do Name { name = x }
    case ["qualid", ...xs]  do xs reified

    # -- DECLARATIONS --
    case ["mod", id, declarations] do 
      Module { 
        interface = Interface_Specifier {
          name = id reified,
          version = Version { major = 1, minor = 0, patch = 0 }
        },

        metadata = false, # FIXME:

        declarations = declarations reified
      }

    case ["record", id, fields] do
      Declaration.Record { 
        name = id reified, 
        fields = fields reified 
      }

    case ["union", id, cases] do
      Declaration.Union { 
        name = id reified, 
        variants = cases reified 
      }

    case ["public", symbols] do
      Declaration.Public { bindings = symbols }

    case ["use", mod, symbols] do
      Declaration.Use { 
        interface = Interface_Specifier {
          name = mod reified,
          version = Version { major = 1, minor = 0, patch = 0 }
        },

        bindings = symbols
      }


    # -- VALUES --
    case ["bool", value] do
      Expression.Boolean { value = value }

    case ["int", sign, value] do
      Expression.Integer_32bit {
        sign = sign, digits = value
      }

    case ["dec", sign, integer, decimal] do
      Expression.Decimal_64bit {
        sign = sign, integer = integer, decimal = decimal
      }

    case ["text", value] do
      Expression.Text { value = value }

    case ["vec", items] do
      Expression.Vector { items = items reified }

    case ["closure", args, expr] do
      Expression.Closure {
        parameters = args reified, 
        expression = expr reified
      }

    # -- EXPRESSIONS --
    case ["if", test, consequent, alternate] do
      Expression.If {
        condition = test reified,
        consequent = consequent reified,
        alternate = alternate reified
      }

    case ["let", id, value, expr] do
      Expression.Let {
        name = id reified,
        value = value reified,
        expression = expr reified
      }

    case ["new", structure, fields] do
      Expression.New {
        structure = structure reified, 
        fields = fields reified
      }

    case ["call", callee, args] do
      Expression.Call {
        callee = callee reified, 
        arguments = args reified
      }

    case ["proj", structure, field] do
      Expression.Project {
        structure = structure reified,
        field = field reified
      }

    case ["deref", id] do
      Expression.Variable { name = id reified }

    case ["match", expr, cases] do
      Expression.Match {
        value = expr reified, 
        cases = cases reified
      }

    case ["case", pattern, expr] do
      Case { 
        pattern = pattern reified, 
        constraint = false, # FIXME:
        expression = expr reified
      }

    # -- PATTERNS --
    case ["patt_any"] do
      Pattern.Any

    case ["patt_eq", value] do
      Pattern.Equals { expression = value reified }

    case ["patt_bind", name] do
      Pattern.Bind { name = name reified }

    case ["patt_unapply", extractor, fields] do
      Pattern.Unapply { extractor = extractor reified, fields = fields reified }

    case ["patt_vec", items, ["none"]] do
      Pattern.Vector { items = items reified, spread = false } # FIXME:

    case ["patt_vec", items, spread] do
      Pattern.Vector { 
        items = items reified, 
        spread = spread reified
      }

    # -- HANDLES UNTAGGED ARRAYS --
    case [...items] do
      items map: { x in x reified }
    
