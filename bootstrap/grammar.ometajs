var reserved = [
  'module', 'where', 'record', 'union', 'case', 'from', 'use', 'public', 'do', 'in', 'if', 'then', 'else', 'match',
  'and', 'or', 'not', 'define', 'true', 'false', 'is', 'foreign', 'root', 'rule', 'override', 'grammar', 'lexeme'
];

function isValid(x) {
  return reserved.indexOf(x) === -1;
}

ometa Grammar {
  newline = /\n\r|\r\n|\n|\r/,
  comment = '#' (~newline any)* newline,
  ignored = space | comment,
  __      = ignored*,
  eof     = ~char,
  
  kw :xs       = seq(xs) ~(letter | digit | '_'),
  listOf :x :s = apply(x):a __ (token(s) __ apply(x))*:b -> [a].concat(b)
               | empty                                   -> [],

  id_start = letter,
  id_rest  = letter | digit | '_',
  base_id  = <id_start id_rest*>,
  id       = <id_start id_rest*>:x ?isValid(x) -> x,
  qual_id  = base_id:a ('.' base_id:x -> x)*:as -> ['qualid', [a].concat(as)],


  stringEscape = '\\' ( 'b' -> '\b'
               | 'f' -> '\f'
               | 'n' -> '\n'
               | 'r' -> '\r'
               | 't' -> '\t'
               | char),
  stringChar = stringEscape:a       -> a
             | (~seq('"') char):a   -> a,
  text       = '"' stringChar*:as '"' -> ['text', as.join('')],

  grammar = __ kw('grammar') __ qual_id:i (__ declaration)+:r __ eof -> ['grammar', i, r],

  declaration = import | override | rule | root,

  import = kw('from') __ qual_id:i __ kw('use') __ '(' __ listOf("id", ','):is __ ')' -> ['use', i, is],

  override = kw('override') __ rule:r -> ['override', r],

  root = kw('root') __ rule:r -> ['root', r],

  rule = kw('lexeme') __ id:i __ text?:t __ '=' __ pattern:p -> ['lexeme', i, t, p]
       | kw('rule')   __ id:i __ text?:t __ '=' __ pattern:p -> ['rule', i, t, p],

  pattern = semantic_action,

  semantic_action = alternative:a __ seq('->') __ expression:e -> ['semantic', a, e]
                  | alternative,
          
  alternative = alternative:a __ '|' __ negate:b -> ['alt', a, b]
              | sequence,

  sequence = sequence:a space __ negate:b -> ['seq', a, b]
           | negate,
  
  negate = '~' __ bind:b -> ['negate', b]
         | bind,

  bind = bind:a ':' id:i -> ['bind', a, i]
       | repeat,

  repeat = repeat:a '*' -> ['many', a]
         | repeat:a '+' -> ['many1', a]
         | primary,

  primary = parameterised_rule_application
          | rule_application
          | text
          | '(' __ pattern:p __ ')' -> p,

  parameterised_rule_application = id:i __ '(' __ listOf("pattern", ','):ps __ ')'  -> ['call', i, ps],

  rule_application = id:i -> ['app', i],
}