//---------------------------------------------------------------------
//
// This source file is part of the Canel.Ã©s project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

module.exports = function(ast) {

  // --[ Helpers ]-----------------------------------------------------
  var reserved = [
    'if', 'else',
    'switch', 'case', 'default',
    'true', 'false',
    'const', 'let',
    'module', 'import', 'export', 'as', 'exposing',
    'try', 'throw',
    'union'
  ];


  function fixNumber(n) {
    return n.replace(/_/g, '');
  }

  function isValid(id) {
    return reserved.indexOf(id) === -1;
  }


  ometa CanelesParser {
    // --[ Lexical structure ]-----------------------------------------
    space   = /\s/,
    ignored = space | comment,
    comment = fromTo('//', '\n'):a -> a.slice(2),
            | fromTo('/*', '*/'):a -> a.slice(2, -2),
    ws      = ignored*,
    eof     = ~char,
    kw :xs  = seq(xs) ~(letter | digit | '!'),


    // --[ Identifiers ]-----------------------------------------------
    IdStart = letter,
    IdRest  = letter | digit,
    IdBang  = '!'?:b  -> (b ? '$BANG' : ''),

    Identifier =
      <IdStart IdRest*>:x IdBang:b  ?isValid(x + b)
    ->  ast.Identifier(x + b),

    Keyword =
      <IdStart IdRest*>:x ':'
    ->  x,


    // --[ Expressions ]-----------------------------------------------
    Expression =
      AssignmentExpression
    | AssignMemberExpression
    | ArrowExpression
    | OrExpression,


    // ---[ Assignment ]-----------------------------------------------
    AssignmentExpression =
      Identifier:i ws seq(':=') ws Expression:e
    -> ast.Assign(i, e),

    AssignMemberExpression =
      OrExpression:e ws '.' ws Identifier:i ws seq(':=') ws Expression:v
    -> ast.AssignMember(e, i, v),


    // ---[ Operators ]------------------------------------------------
    OrExpression =
      OrExpression:l ws seq('||') ws AndExpression:r
    -> ast.Infix('||', l, r)
    | AndExpression,

    AndExpression =
      AndExpression:l ws seq('&&') ws EqualityExpression:r
    -> ast.Infix('&&', l, r)
    | EqualityExpression,

    EqualityExpression =
      EqualityExpression:l ws (seq('===') | seq('=/=')):op ws RelationalExpression:r
    -> ast.Infix(op, l, r)
    | RelationalExpression,

    RelationalExpression =
      RelationalExpression:l ws ('>' | seq('>=') | '<' | seq('<=')):op ws AddExpression:r
    -> ast.Infix(op, l, r)
    | AddExpression,

    AddExpression =
      AddExpression:l ws ('+' | '-'):op ws MultiplyExpression:r
    -> ast.Infix(op, l, r)
    | MultiplyExpression,

    MultiplyExpression =
      MultiplyExpression:l ws ('*' | '/' | '^'):op ws UnaryExpression:r
    -> ast.Infix(op, l, r)
    | UnaryExpression,

    UnaryExpression =
      '~' ws PrimaryExpression:r
    -> ast.Prefix('~', r)
    | PrimaryExpression,

    PrimaryExpression =
      TryExpression
    | ThrowExpression
    | UnionExpression
    | SwitchExpression
    | InvokeExpression
    | MemberExpression,

    InvokeExpression =
      InvokeExpression:e ws (
        '(' ws ArgumentList?:xs ws ')'                               -> ast.Call(e, xs || [])
      | '.' ws Identifier:i ws '(' ws KeywordArgumentList:xs ws ')'  -> ast.KeywordMethodCall(e, i, xs)
      | '.' ws Identifier:i ws '(' ws ArgumentList?:xs ws ')'        -> ast.MethodCall(e, i, xs || [])
      | '.' ws Identifier:i         -> ast.Member(e, i)
      | '[' ws Expression:k ws ']'  -> ast.Subscript(e, k)
      )
    | SimpleExpression,

    MemberExpression =
      MemberExpression:e ws '.' ws Identifier:i
    -> ast.Member(e, i)
    | SubscriptExpression,

    SubscriptExpression =
      SubscriptExpression:e ws '[' ws Expression:k ws ']'
    -> ast.Subscript(e, k)
    | SimpleExpression,

    SimpleExpression =
      ObjectExpression
    | Value
    | Identifier:a                -> a
    | '(' ws Expression:e ws ')'  -> e,


    // ---[ Functions ]------------------------------------------------
    ParameterList =
      Identifier:x
      (ws ',' ws Identifier)*:xs
      (ws ',' ws RestParameter)?:x2
    -> [x].concat(xs).concat(x2 ? [x2] : []),

    RestParameter =
      seq('...') Identifier:x   -> ast.Rest(x),

    ArgumentList =
      Argument:x (ws ',' ws Argument)*:xs
    -> [x].concat(xs),

    Argument =
      seq('...') Expression:e   -> ast.Spread(e)
    | Expression:e              -> e,

    KeywordArgumentList =
      KeywordArgument:x (ws ',' ws KeywordArgument)*:xs
    -> [x].concat(xs),

    KeywordArgument =
      Keyword:k ws Expression:e
    -> [k, e],

    ArrowExpression =
      '(' ws ParameterList:p ws ')' ws seq('=>') ws ArrowBody:b  -> ast.Function(p, b)
    | Identifier:i ws seq('=>') ws ArrowBody:b                   -> ast.Function([i], b),

    ArrowBody =
      Expression:e                    -> [ast.Return(e)],
    | '{' ws StatementList:xs ws '}'  -> xs,


    // ---[ Unions ]---------------------------------------------------
    UnionExpression =
      kw('union') ws String?:tag ws '{' ws VariantList:xs ws '}'
    -> ast.Union(tag || ast.String(''), xs),

    UnionVariant =
      Identifier:i ws '(' ws UnionVariantParameters:xs ws ')'   -> ast.Variant(i, xs)
    | Identifier:i                                              -> ast.Variant(i, []),

    UnionVariantParameters =
      Identifier:x (ws ',' ws Identifier)*:xs
    -> [x].concat(xs),

    VariantList =
      UnionVariant:x (ws ',' ws UnionVariant)*:xs
    -> [x].concat(xs),


    // ---[ Pattern Matching ]-----------------------------------------
    SwitchExpression =
      kw('switch') ws Expression:e ws '{' ws SwitchCases:xs ws '}'
    -> ast.Switch(e, xs),

    SwitchCases =
      SwitchCase:x (ws SwitchCase)*:xs
    -> [x].concat(xs),

    SwitchCase =
      SwitchMatchAny
    | SwitchMatchCase,

    SwitchMatchCase =
      kw('case') ws SwitchPattern:p (ws SwitchConstraint)?:c ws ':' ws StatementList:xs
    -> ast.SwitchCase(p, c || ast.SwitchNoConstraint(), xs),

    SwitchPattern =
      PatternWildcard
    | PatternConstBinding
    | PatternLetBinding
    | PatternVariant
    | PatternEqual,

    PatternWildcard =
      '_'
    -> ast.PatternWildcard(),

    PatternConstBinding =
      kw('const') ws Identifier:i
    -> ast.PatternConstBinding(i),

    PatternLetBinding =
      kw('let') ws Identifier:i
    -> ast.PatternLetBinding(i),

    PatternVariant =
      '.' ws MemberExpression:m ws '(' ws PatternList:xs ws ')'   -> ast.PatternVariant(m, xs)
    | '.' ws MemberExpression:m                                   -> ast.PatternVariant(m, []),

    PatternEqual =
      Expression:e
    -> ast.PatternEqual(e),

    PatternList =
      SwitchPattern:x (ws ',' ws SwitchPattern)*:xs
    -> [x].concat(xs),

    SwitchConstraint =
      kw('if') ws Expression:e
    -> ast.SwitchBooleanConstraint(e),

    SwitchMatchAny =
      kw('default') ws ':' ws StatementList:xs
    -> ast.SwitchDefaultCase(xs),


    // ---[ Object ]---------------------------------------------------
    ObjectExpression =
      '{' ws ObjectProperties:xs ws '}'
    -> ast.Object(xs),

    ObjectProperties =
      ObjectProperty:x (ws ',' ws ObjectProperty)*:xs
    -> [x].concat(xs),

    ObjectProperty =
      Getter
    | Setter
    | KeywordMethod
    | Method,

    NameAndReceiver =
      Identifier:r ws '.' ws Identifier:i  -> ({ name: i, receiver: r   })
    | Identifier:i                         -> ({ name: i, receiver: ast.Identifier('_') }),

    Getter =
      Decorators?:d
      ws
      kw('get') ws NameAndReceiver:x ws Block:b
    -> ast.Getter(x.receiver, x.name, b, d || []),

    Setter =
      Decorators?:d
      ws
      kw('set') ws NameAndReceiver:x ws '(' ws Identifier:i ws ')' ws Block:b
    -> ast.Setter(x.receiver, x.name, i, b, d || []),

    Method =
      Decorators?:d
      ws
      NameAndReceiver:x ws '(' ws ParameterList?:ps ws ')' ws Block:b
    -> ast.Method(x.receiver, x.name, ps || [], b, d || []),

    KeywordMethod =
      Decorators?:d
      ws
      NameAndReceiver:x ws '(' ws KeywordParameterList:ps ws ')' ws Block:b
    -> ast.KeywordMethod(x.receiver, x.name, ps, b, d || []),

    KeywordParameterList =
      KeywordParameter:x (ws ',' ws KeywordParameter)*:xs
    -> [x].concat(xs),

    KeywordParameter =
      Keyword:k ws Identifier:i
    -> [k, i],

    Decorators =
      Decorator:x (ws Decorator)*:xs
    -> [x].concat(xs),

    Decorator =
      '@' ws Expression:e
    -> e,


    // ---[ Error Handling ]-------------------------------------------
    TryExpression =
      kw('try') ws Expression:e
    -> ast.Try(e),

    ThrowExpression =
      kw('throw') ws Expression:e
    -> ast.Throw(e),



    // --[ Values ]----------------------------------------------------
    Value =
      Boolean
    | BinaryInteger
    | OctalInteger
    | HexadecimalInteger
    | FloatNumber
    | DecimalNumber
    | DecimalInteger
    | String
    | Vector
    | Map
    | Set,


    // ---[ Boolean ]-------------------------------------------------
    Boolean =
      kw('true')   -> ast.Boolean(true)
    | kw('false')  -> ast.Boolean(false),


    // ---[ Numbers ]--------------------------------------------------
    OctalDigit = /[0-7_]/,
    HexDigit   = /[0-9a-fA-F_]/,
    BinDigit   = /[01_]/,
    DecDigit   = /[0-9_]/,
    Sign       = ('-' | '+')?:a                     -> a || '+',
    Exponent   = ('e' | 'E') Sign:s <DecDigit+>:n   -> s + fixNumber(n),

    BinaryInteger =
      seq('0b') Sign:s <BinDigit+>:n
    -> ast.Integer(s, fixNumber(n), 2),

    OctalInteger =
      seq('0o') Sign:s <OctalDigit+>:n
    -> ast.Integer(s, fixNumber(n), 8),

    HexadecimalInteger =
      seq('0x') Sign:s <HexDigit+>:n
    -> ast.Integer(s, fixNumber(n), 16),

    DecimalInteger =
      Sign:s <DecDigit+>:n
    -> ast.Integer(s, fixNumber(n), 10),

    DecimalNumber =
      Sign:s <DecDigit+>:i '.' <DecDigit+>:d Exponent?:e
    -> ast.Decimal(s, fixNumber(i) + '.' + fixNumber(d) + (e || '')),

    FloatNumber =
      Sign:s <DecDigit+>:i '.' <DecDigit+>:d Exponent?:e 'f'
    -> ast.Float(Number(s + fixNumber(i) + '.' + fixNumber(d) + (e || ''))),


    // ---[ Strings ]--------------------------------------------------
    StringEscape =
      '\\' ( 'b' -> '\b'
           | 'f' -> '\f'
           | 'n' -> '\n'
           | 'r' -> '\r'
           | 't' -> '\t'
           | char),

    StringCharacter =
      (StringEscape | (~seq('"') char)):a
    -> a,

    UnescapableCharacters =
      ~seq('"""') char,

    String =
      seq('"""') <UnescapableCharacters*>:xs seq('"""')   -> ast.String(xs)
    | '"' StringCharacter*:xs '"'                         -> ast.String(xs.join('')),


    // ---[ Vectors ]--------------------------------------------------
    Vector =
      '[' ws ItemList?:xs ws ']'
    -> ast.Vector(xs || []),

    ItemList =
      Item:x (ws ',' ws Item)*:xs -> [x].concat(xs),

    Item =
      seq('...') Expression:e  -> ast.Spread(e)
    | Expression:e             -> e,

    // ---[ Sets ]-----------------------------------------------------
    Set =
      seq('#[') ws ItemList?:xs ws ']'
    -> ast.Set(xs || []),


    // ---[ Maps ]-----------------------------------------------------
    Map =
      '[' ws MapAssociations:xs ws ']'  -> ast.Map(xs)
    | '[' ws ':' ws ']'                 -> ast.Map([]),

    MapAssociation =
      Expression:k ws ':' ws Expression:v   -> [k, v],

    MapAssociations =
      MapAssociation:x (ws ',' ws MapAssociation)*:xs   -> [x].concat(xs),


    // --[ Statements ]------------------------------------------------
    Statement =
      ConstDeclaration
    | LetDeclaration
    | IfThenElseStatement
    | ReturnStatement
    | Expression,

    StatementList =
      Statement:x (ws ';' ws StatementList)?:xs   -> [x].concat(xs || [])
    | Statement:x (ws ';')?                       -> [x],

    Block =
      '{' ws StatementList:xs ws '}'
    -> xs,


    // ---[ Declarations ]---------------------------------------------
    ConstDeclaration =
      kw('const') ws Identifier:i ws '=' ws Expression:e
    -> ast.Const(i, e),

    LetDeclaration =
      kw('let') ws Identifier:i ws '=' ws Expression:e
    -> ast.Let(i, e),


    // ---[ Control flow ]---------------------------------------------
    IfThenElseStatement =
      kw('if') ws Expression:t ws Block:c ws Alternate?:a
    -> ast.IfThenElse(t, c, a || []),

    Alternate =
      kw('else') ws IfThenElseStatement:e  -> [e]
    | kw('else') ws Block:es               -> es,

    ReturnStatement =
      kw('return') ws Expression:e
    -> ast.Return(e),


    // --[ Module ]----------------------------------------------------
    ModuleDeclaration =
      kw('module')
      ws '(' ws ParameterList?:xs ws ')'
      ws '{' ws TopLevelDeclarationList?:body ws '}'
    -> ast.Module(xs || [], body || []),

    ExportDeclaration =
      kw('export') ws (
        ConstDeclaration:x   -> ast.Export(x.identifier, x.identifier)
      | LetDeclaration:x     -> ast.Export(x.identifier, x.identifier)
      | Identifier:i         -> ast.Export(i, i)
      ),

    ImportDeclaration =
      kw('import')
      ws String:m
      (ws '(' ws ArgumentList:xs ws ')' -> xs)?:xs
      ws ImportBinding?:b
      ws ImportExpose?:e
    -> ast.Import(m, xs || null, e || [], b),

    ImportBinding =
      kw('as') ws Identifier:i -> i,

    ImportExpose =
      kw('exposing') ws '(' ws ImportName:x (ws ',' ws ImportName)*:xs ws ')'
    -> [x].concat(xs),

    ImportName =
      Identifier:i ws kw('as') ws Identifier:n  -> [i, n]
    | Identifier:i                              -> [i, i],

    // --[ Top Level ]-------------------------------------------------
    TopLevelDeclaration =
      ModuleDeclaration
    | ImportDeclaration
    | ExportDeclaration
    | Statement,

    TopLevelDeclarationList =
      TopLevelDeclaration:x (ws ';' ws TopLevelDeclarationList)?:xs  -> [x].concat(xs || [])
    | TopLevelDeclaration:x (ws ';')?                                -> [x],

    Program =
      ws TopLevelDeclarationList?:xs ws eof -> ast.Program(xs || [])
  }


  return {
    parse: function(source) {
      return CanelesParser.matchAll(source, 'Program');
    },

    Parser: CanelesParser
  }
}