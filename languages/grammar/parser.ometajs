//---------------------------------------------------------------------
//
// This source file is part of the Canel.Ã©s project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

module.exports = function(ast) {

  var reserved = [
    'if', 'root', 'rule', 'support', 'grammar',
    'location', 'elements', 'text'
  ];

  function isValid(a) {
    return reserved.indexOf(a) === -1;
  }


  function generateVariant(rule) {
    var name = rule[1];

    return ast.Variant(
      ast.Identifier(name),
      ['location', 'text', 'elements'].map(function(x) {
        return ast.Identifier(x);
      })
    );
  }

  function compare(a, b) {
    return a < b ?  -1
    :      a > b ?   1
    :                0;
  }

  function collectVariants(rules) {
    return rules.filter(function(rule) {
      return rule[0] !== 'support';
    })
  }

  function collectRoots(rules) {
    return rules.filter(function(rule) {
      return rule[0] === 'root';
    }).map(function(rule) {
      return rule[1];
    });
  }

  function generateExpr(e) {
    switch (e[0]) {
      case 'seq':
        return e[1].map(generateExpr).join(' ');

      case 'choice':
        return generateExpr(e[1]) + ' / ' + generateExpr(e[2]);

      case 'lookahead':
        return '&' + generateExpr(e[1]);

      case 'negative':
        return '!' + generateExpr(e[1]);

      case 'label':
        return e[1] + ':' + generateExpr(e[2]);

      case 'many':
        return generateExpr(e[1]) + '*';

      case 'many1':
        return generateExpr(e[1]) + '+';

      case 'maybe':
        return generateExpr(e[1]) + '?';

      case 'lit':
        return '"' + e[1] + '"';

      case 'group':
        return '[' + e[1] + ']';

      case 'par':
        return '(' + generateExpr(e[1]) + ')'

      case 'app':
        return e[1];

      case 'action':
      case 'predicate':
        throw new Error('Action/Predicate not supported yet.');
    }
  }

  function generateBinding(name) {
    return function(rule) {
      var expr = rule[0];
      var labels = rule[1].map(function(x) {
        return '[' + JSON.stringify(x) + ', ' + x + ']'
      }).join(', ');

      return [
        generateExpr(expr), ' {',
          'return options.ast.', name, '(location, text, options.map([', labels , ']))',
        '}'
      ].join('');
    }
  }

  function generatePegRule(rule) {
    var name = rule[1];
    var exprs = rule[2];

    return name + ' = ' + exprs.map(generateBinding(name)).join(' / ');
  }

  function generatePegGrammar(rules) {
    return rules.map(generatePegRule).join('\n\n');
  }

  function makeGrammar(name, rules) {
    var sortedRules = rules.sort(function(a, b){ return compare(a[1], b[1]) });
    var variants = collectVariants(rules);
    var roots = collectRoots(rules);

    return ast.Program([
      ast.Const(
        ast.Identifier('peg'),
        ast.Runtime('pegjs', [])
      ),

      ast.Const(
        ast.Identifier('ast'),
        ast.Union(
          ast.String(name),
          variants.map(generateVariant)
        )
      ),
      ast.Export(ast.Identifier('ast'), ast.Identifier('ast')),

      ast.Const(
        ast.Identifier('parse'),
        ast.Call(
          ast.Identifier('peg'),
          [
            ast.String(generatePegGrammar(rules)),
            ast.Identifier('ast'),
            ast.Tuple(
              roots.map(function(x) {
                return ast.String(x);
              })
            )
          ]
        )
      ),
      ast.Export(ast.Identifier('parse'), ast.Identifier('parse'))
    ])
  }

  ometa Grammar {
    // --[ Lexical structure ]-----------------------------------------
    space   = /\s/,
    ignored = space | comment,
    comment = fromTo('//', '\n'):a -> a.slice(2)
            | fromTo('/*', '*/'):a -> a.slice(2, -2),
    ws      = ignored*,
    ows     = ignored+,
    eof     = ~char,
    kw :xs  = seq(xs) ~(letter | digit),

    IdStart    = letter | '_',
    IdRest     = letter | digit | '_',
    Identifier = <IdStart IdRest*>:a ?isValid(a) -> a,

    // --[ Rules ]-----------------------------------------------------
    Root =
      kw('grammar') ws Identifier:name ws Rules:rules ws eof -> makeGrammar(name, rules),

    Rules =
      Rule:x (ws Rule)*:xs -> [x].concat(xs),

    Rule =
      kw('root') ws Identifier:name ws '=' ws TopLevel:xs             -> ['root', name, xs]
    | kw('support') ws Identifier:name ws '=' ws TopLevel:xs  -> ['support', name, xs]
    | kw('rule') ws Identifier:name ws '=' ws TopLevel:xs             -> ['rule', name, xs],

    TopLevel =
      BindExpression:x (ws '/' ws BindExpression)*:xs -> [x].concat(xs),

    BindExpression =
      RuleExpressions:x ws MaybeBind:b -> [x, b]
    | RuleExpressions:x                -> [x, []],

    MaybeBind =
      seq('=>') ws '(' ws IdList:xs ws ')' -> xs,

    IdList =
      Identifier:x (ws ',' ws Identifier)*:xs -> [x].concat(xs),

    RuleExpressions =
      RuleExpression:x (ows RuleExpression)*:xs -> ['seq', [x].concat(xs)],

    RuleExpression =
      ChoiceExpression:e,

    ChoiceExpression =
      ChoiceExpression:e ws '/' ws RuleExpression:e2 -> ['choice', e, e2]
    | AssertExpression,

    AssertExpression =
      LookaheadExpression
    | NegativeLookaheadExpression
    | LabelledExpression,

    LookaheadExpression =
      '&' ws RuleExpression:e -> ['lookahead', e],

    NegativeLookaheadExpression =
      '!' ws RuleExpression:e -> ['negative', e],

    LabelledExpression =
      Identifier:i ws ':' ws ManyExpression:e -> ['label', i, e]
    | ManyExpression,

    ManyExpression =
      ManyExpression:e ws '*' -> ['many', e]
    | Many1Expression,

    Many1Expression =
      Many1Expression:e ws '+' -> ['many1', e]
    | MaybeExpression,

    MaybeExpression =
      MaybeExpression:e ws '?' -> ['maybe', e]
    | Terminal,

    Terminal =
      Literal
    | CharacterGroup
    | RuleApplication
    | '(' ws RuleExpression:e ws ')' -> ['par', e],


    Escape =
      '\\' char:a -> '\\' + a,

    LiteralCharacter =
      (Escape | (~seq('"') char)):a   -> a,

    Literal =
      '"' LiteralCharacter*:xs '"'  -> ['lit', xs.join('')],

    CharacterGroupItem =
      Escape
    | ~seq(']') char,

    CharacterGroup =
      '[' CharacterGroupItem*:xs ']' -> ['group', xs.join('')],

    RuleApplication =
      Identifier:i  -> ['app', i]
  }

  return {
    parse: function(source) {
      return Grammar.matchAll(source, 'Root');
    }
  }
};
